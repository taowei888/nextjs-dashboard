# 部分预渲染文档

## 概述
本文档详细介绍 Next.js 仪表板项目中的部分预渲染（Partial Prerendering, PPR）实现，展示如何结合静态和动态渲染的优势，实现最佳的性能和用户体验。

## 部分预渲染概念

### 什么是部分预渲染
部分预渲染是 Next.js 的一项实验性功能，允许在同一个路由中同时使用静态和动态渲染：

- 🚀 **静态部分**：在构建时预渲染，可以被 CDN 缓存
- ⚡ **动态部分**：在请求时渲染，提供实时数据
- 🔄 **流式传输**：动态部分通过 Suspense 流式传输到客户端

### 传统方式 vs 部分预渲染

#### 传统全静态渲染
```
构建时：生成完整的静态 HTML
请求时：直接返回静态内容（数据可能过时）
```

#### 传统全动态渲染
```
请求时：服务器渲染整个页面（包括静态部分）
缺点：静态内容无法缓存，每次都要重新渲染
```

#### 部分预渲染
```
构建时：预渲染静态部分（布局、导航等）
请求时：只渲染动态部分（实时数据）
结果：静态部分瞬间加载 + 动态部分流式更新
```

## 项目中的 PPR 配置

### 全局配置 (`next.config.ts`)
```typescript
import type { NextConfig } from 'next';

const nextConfig: NextConfig = {
  experimental: {
    ppr: "incremental",  // 启用增量 PPR
  },
};

export default nextConfig;
```

**配置说明：**
- `ppr: "incremental"`：启用增量部分预渲染
- 允许逐步采用 PPR，而不是全局启用
- 需要在具体路由中显式启用

### 路由级别配置 (`app/dashboard/layout.tsx`)
```typescript
import SideNav from "@/app/ui/dashboard/sidenav";
export const experimental_ppr = true;  // 启用 PPR

export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <div className="flex h-screen flex-col md:flex-row md:overflow-hidden">
      <div className="w-full flex-none md:w-64">
        <SideNav />  {/* 静态预渲染部分 */}
      </div>
      <div className="flex-grow p-6 md:overflow-y-auto md:p-12">
        {children}  {/* 动态渲染部分 */}
      </div>
    </div>
  );
}
```

## PPR 架构分析

### 静态预渲染部分

#### 1. 布局结构
```typescript
// app/dashboard/layout.tsx:4-13
export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <div className="flex h-screen flex-col md:flex-row md:overflow-hidden">
      <div className="w-full flex-none md:w-64">
        <SideNav />  {/* ✅ 静态：导航菜单 */}
      </div>
      <div className="flex-grow p-6 md:overflow-y-auto md:p-12">
        {children}  {/* 🔄 动态：页面内容 */}
      </div>
    </div>
  );
}
```

**静态预渲染的元素：**
- 页面布局结构
- 侧边导航菜单 (`SideNav`)
- CSS 样式和响应式布局
- 基础的 HTML 框架

#### 2. 侧边导航组件
```typescript
// SideNav 组件包含的静态内容：
- Logo 和品牌信息
- 导航链接（Home、Invoices、Customers）
- 登出按钮
- 静态图标和样式
```

### 动态渲染部分

#### 1. 仪表板页面内容
```typescript
// app/dashboard/(overview)/page.tsx:16-42
export default async function Page() {
  // 🔄 动态数据获取
  const cardData = await fetchCardData();

  return (
    <main>
      <h1>Dashboard</h1>  {/* ✅ 可以静态预渲染 */}

      {/* 🔄 动态：统计卡片 */}
      <div className="grid gap-6 sm:grid-cols-2 lg:grid-cols-4">
        <Suspense fallback={<CardsSkeleton />}>
          <CardWrapper />
        </Suspense>
      </div>

      {/* 🔄 动态：图表和发票列表 */}
      <div className="mt-6 grid grid-cols-1 gap-6 md:grid-cols-4 lg:grid-cols-8">
        <Suspense fallback={<RevenueChartSkeleton />}>
          <RevenueChart />
        </Suspense>
        <Suspense fallback={<LatestInvoicesSkeleton />}>
          <LatestInvoices />
        </Suspense>
      </div>
    </main>
  );
}
```

**动态渲染的元素：**
- 实时统计卡片数据
- 收入图表（包含 3 秒延迟）
- 最新发票列表
- 数据库驱动的内容

## PPR 渲染流程

### 构建时（Build Time）
```bash
npm run build
```

**静态预渲染过程：**
1. 分析 `experimental_ppr = true` 的路由
2. 识别静态和动态边界（Suspense 边界）
3. 预渲染静态部分：
   ```html
   <div class="flex h-screen flex-col md:flex-row">
     <div class="w-full flex-none md:w-64">
       <!-- 预渲染的 SideNav 内容 -->
     </div>
     <div class="flex-grow p-6 md:overflow-y-auto md:p-12">
       <main>
         <h1>Dashboard</h1>
         <!-- 动态部分的占位符 -->
       </main>
     </div>
   </div>
   ```
4. 生成静态 HTML 文件和 JavaScript chunks

### 请求时（Request Time）
```
用户请求 /dashboard
    ↓
1. 立即返回静态预渲染内容（布局+导航）
    ↓
2. 开始服务器端渲染动态部分
    ↓
3. 通过流式传输发送动态内容
    ↓
4. 客户端接收并替换 Suspense fallback
```

### 具体时序
```
时间轴：0ms ---- 50ms ---- 100ms ---- 3000ms ---- 3500ms
       静态内容  骨架屏    卡片数据    图表数据    完成

用户体验：
0ms：    立即看到完整布局和导航
50ms：   看到仪表板标题和骨架屏
100ms：  统计卡片和发票列表显示
3000ms： 收入图表完成加载（含演示延迟）
```

## 性能优势分析

### 传统全动态渲染
```
请求 → 等待所有数据 → 渲染完整页面 → 返回
      (3000ms+)      (渲染时间)    (网络时间)

总时间：3000ms + 渲染时间 + 网络时间
首屏内容：3000ms 后才显示
```

### 部分预渲染
```
请求 → 立即返回静态部分 → 并行获取动态数据 → 流式更新
      (< 50ms)           (3000ms)         (实时)

首屏内容：< 50ms 显示布局和导航
完整内容：动态部分逐步加载
```

### 性能指标对比

| 指标 | 传统动态渲染 | 部分预渲染 | 改善 |
|------|-------------|-----------|------|
| **首次内容绘制 (FCP)** | 3000ms+ | < 50ms | 60x+ |
| **最大内容绘制 (LCP)** | 3500ms+ | 3000ms | 15%+ |
| **累积布局偏移 (CLS)** | 高 | 低 | 显著改善 |
| **首次输入延迟 (FID)** | 高 | 低 | 显著改善 |

## 缓存策略

### 静态部分缓存
```
CDN 边缘节点
├── 预渲染的 HTML（布局+导航）
├── CSS 样式文件
├── JavaScript chunks
└── 静态资源（图标、图片）

缓存时间：长期缓存（直到下次部署）
```

### 动态部分缓存
```
应用服务器
├── 数据库查询结果
├── API 响应缓存
└── 计算结果缓存

缓存策略：短期缓存或实时数据
```

## 实现细节

### Suspense 边界策略
```typescript
// 细粒度的 Suspense 边界
<Suspense fallback={<CardsSkeleton />}>
  <CardWrapper />        // 快速数据
</Suspense>

<Suspense fallback={<RevenueChartSkeleton />}>
  <RevenueChart />       // 慢速数据（3秒）
</Suspense>

<Suspense fallback={<LatestInvoicesSkeleton />}>
  <LatestInvoices />     // 中速数据
</Suspense>
```

**优势：**
- 每个组件独立加载，不会相互阻塞
- 用户可以立即与快速加载的部分交互
- 渐进式内容展示

### 数据获取优化
```typescript
// 组件内部数据获取
export default async function CardWrapper() {
  // 🔄 在组件内部获取数据，支持并行执行
  const cardData = await fetchCardData();
  return <Cards data={cardData} />;
}

export default async function RevenueChart() {
  // 🔄 独立的数据获取，不影响其他组件
  const revenue = await fetchRevenue(); // 3秒延迟
  return <Chart data={revenue} />;
}
```

## 兼容性和限制

### Next.js 版本要求
```json
{
  "next": "15.6.0-canary.20"  // 需要 canary 版本
}
```

### 实验性功能注意事项
- ⚠️ **实验性特性**：API 可能会发生变化
- 🔧 **开发阶段**：建议在测试环境充分验证
- 📈 **逐步采用**：使用 `incremental` 模式逐步启用

### 当前限制
1. **组件边界**：需要合理设计 Suspense 边界
2. **状态管理**：客户端状态需要妥善处理
3. **SEO 考虑**：动态内容可能不会被搜索引擎索引

## 调试和监控

### 开发模式调试
```bash
npm run dev
```

在开发模式下，可以观察到：
- 静态部分立即加载
- 动态部分的 Suspense fallback
- 数据加载和内容替换过程

### 生产模式验证
```bash
npm run build
npm run start
```

### 性能监控代码
```typescript
// 可以添加性能监控
if (typeof window !== 'undefined') {
  // 监控静态内容加载
  window.addEventListener('DOMContentLoaded', () => {
    console.log('Static content loaded');
  });

  // 监控动态内容加载
  const observer = new MutationObserver(() => {
    console.log('Dynamic content updated');
  });
}
```

## 最佳实践

### 1. 静态/动态边界设计
```typescript
// ✅ 好的做法：清晰的边界
<div className="layout">           {/* 静态 */}
  <Header />                       {/* 静态 */}
  <Nav />                         {/* 静态 */}
  <main>
    <h1>Page Title</h1>           {/* 静态 */}
    <Suspense fallback={<Skeleton />}>
      <DynamicContent />          {/* 动态 */}
    </Suspense>
  </main>
</div>

// ❌ 避免：混合静态和动态内容
<div>
  <StaticPart />
  <DynamicPart />   {/* 没有 Suspense 包装 */}
  <AnotherStaticPart />
</div>
```

### 2. 骨架屏设计
```typescript
// ✅ 匹配真实内容的骨架屏
export function CardsSkeleton() {
  return (
    <>
      <CardSkeleton />  {/* 4个卡片对应4个骨架 */}
      <CardSkeleton />
      <CardSkeleton />
      <CardSkeleton />
    </>
  );
}
```

### 3. 错误处理
```typescript
// 结合 Error Boundary
<ErrorBoundary fallback={<ErrorUI />}>
  <Suspense fallback={<Loading />}>
    <DynamicComponent />
  </Suspense>
</ErrorBoundary>
```

## 未来发展

### PPR 路线图
1. **稳定版本**：从实验性功能转为稳定特性
2. **更多控制**：细粒度的缓存控制
3. **工具集成**：更好的开发工具和调试支持

### 扩展应用
```typescript
// 未来可能的应用场景
export const experimental_ppr = true;

// 电商网站：静态布局 + 动态价格/库存
// 社交媒体：静态界面 + 动态内容流
// 新闻网站：静态模板 + 动态文章内容
```

## 总结

部分预渲染为 Next.js 应用带来了革命性的性能提升：

### ✅ 核心优势
- **即时加载**：静态部分瞬间显示
- **渐进式体验**：动态内容逐步加载
- **最佳性能**：结合静态和动态渲染的优势
- **SEO 友好**：静态部分完全可索引

### 🔧 实现要点
- **配置简单**：`next.config.ts` + `experimental_ppr = true`
- **边界清晰**：合理使用 Suspense 分割静态和动态内容
- **版本要求**：需要 Next.js 15.6+ canary 版本

### 🚀 性能提升
- **首屏时间**：从 3000ms+ 降至 < 50ms
- **用户体验**：立即可交互的界面
- **缓存效率**：静态部分享受 CDN 缓存优势

部分预渲染代表了 Web 应用性能优化的未来方向，为开发者提供了在保持动态功能的同时实现静态性能的完美解决方案。