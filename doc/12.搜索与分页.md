# 搜索与分页文档

## 概述
本文档详细介绍 Next.js 仪表板项目中的搜索与分页功能实现，展示如何使用 URL 状态管理、防抖搜索、流式传输等现代 Web 技术构建高性能的数据浏览体验。

## 功能特性

### 核心功能
- 🔍 **实时搜索**：输入时即时过滤发票数据
- 📄 **智能分页**：动态生成分页控件
- 🌐 **URL 状态同步**：搜索和分页状态保存在 URL 中
- ⚡ **防抖优化**：减少不必要的 API 请求
- 📱 **响应式设计**：移动端和桌面端适配
- 🔄 **流式传输**：Suspense 支持的加载状态

### 搜索功能
- 多字段搜索：客户姓名、邮箱、金额、日期、状态
- 大小写不敏感的模糊匹配
- 搜索时自动重置到第一页

### 分页功能
- 智能分页算法：自动处理省略号显示
- 每页固定显示 6 条记录
- 前进/后退导航按钮
- 页面状态持久化

## 架构实现

### 页面结构 (`app/dashboard/invoices/page.tsx`)

#### 异步页面组件
```typescript
export default async function Page(props: {
  searchParams?: Promise<{
    query?: string;
    page?: string;
  }>;
}) {
  // 🔄 异步获取 URL 参数
  const searchParams = await props.searchParams;
  const query = searchParams?.query || "";
  const currentPage = Number(searchParams?.page) || 1;

  // 📊 服务器端计算总页数
  const totalPages = await fetchInvoicesPages(query);

  return (
    <div className="w-full">
      {/* 页面标题 */}
      <div className="flex w-full items-center justify-between">
        <h1 className={`${lusitana.className} text-2xl`}>Invoices</h1>
      </div>

      {/* 搜索和操作区域 */}
      <div className="mt-4 flex items-center justify-between gap-2 md:mt-8">
        <Search placeholder="Search invoices..." />
        <CreateInvoice />
      </div>

      {/* 数据表格 - 支持流式传输 */}
      <Suspense key={query + currentPage} fallback={<InvoicesTableSkeleton />}>
        <Table query={query} currentPage={currentPage} />
      </Suspense>

      {/* 分页控件 */}
      <div className="mt-5 flex w-full justify-center">
        <Pagination totalPages={totalPages} />
      </div>
    </div>
  );
}
```

#### 关键特性分析

**URL 参数处理**
```typescript
// Next.js 15 新语法：异步 searchParams
const searchParams = await props.searchParams;
const query = searchParams?.query || "";
const currentPage = Number(searchParams?.page) || 1;
```

**Suspense 边界键**
```typescript
// 使用组合键确保正确的重新渲染
<Suspense key={query + currentPage} fallback={<InvoicesTableSkeleton />}>
```

## 搜索功能实现

### 搜索组件 (`app/ui/search.tsx`)

#### 客户端搜索逻辑
```typescript
'use client';
import { useDebouncedCallback } from "use-debounce";
import { useSearchParams, usePathname, useRouter } from "next/navigation";

export default function Search({ placeholder }: { placeholder: string }) {
  // 🧭 Next.js 导航 hooks
  const searchParams = useSearchParams();
  const pathname = usePathname();
  const { replace } = useRouter();

  // ⏱️ 防抖搜索处理器
  const handleSearch = useDebouncedCallback((term) => {
    console.log(`Searching... ${term}`);

    const params = new URLSearchParams(searchParams);
    params.set("page", "1");  // 搜索时重置到第一页

    if (term) {
      params.set("query", term);
    } else {
      params.delete("query");  // 清空搜索时删除参数
    }

    // 🔄 更新 URL 和触发重新渲染
    replace(`${pathname}?${params.toString()}`);
  }, 300);  // 300ms 防抖延迟

  return (
    <div className="relative flex flex-1 flex-shrink-0">
      <label htmlFor="search" className="sr-only">Search</label>
      <input
        className="peer block w-full rounded-md border border-gray-200 py-[9px] pl-10 text-sm outline-2 placeholder:text-gray-500"
        placeholder={placeholder}
        onChange={(e) => handleSearch(e.target.value)}
        defaultValue={searchParams.get("query")?.toString()}
      />
      <MagnifyingGlassIcon className="absolute left-3 top-1/2 h-[18px] w-[18px] -translate-y-1/2 text-gray-500 peer-focus:text-gray-900" />
    </div>
  );
}
```

#### 搜索功能特性

**防抖优化**
```typescript
// 使用 use-debounce 库实现防抖
const handleSearch = useDebouncedCallback((term) => {
  // 搜索逻辑
}, 300);  // 300ms 延迟
```

**URL 状态管理**
```typescript
const params = new URLSearchParams(searchParams);
params.set("page", "1");        // 搜索时重置分页
params.set("query", term);       // 设置搜索词
replace(`${pathname}?${params.toString()}`);  // 更新 URL
```

**状态同步**
```typescript
// 从 URL 恢复搜索状态
defaultValue={searchParams.get("query")?.toString()}
```

## 分页功能实现

### 分页组件 (`app/ui/invoices/pagination.tsx`)

#### 客户端分页逻辑
```typescript
'use client';
import { usePathname, useSearchParams } from "next/navigation";
import { generatePagination } from '@/app/lib/utils';

export default function Pagination({ totalPages }: { totalPages: number }) {
  // 🧭 获取当前路径和参数
  const pathname = usePathname();
  const searchParams = useSearchParams();
  const currentPage = Number(searchParams.get("page")) || 1;

  // 🔗 创建页面 URL 的辅助函数
  const createPageURL = (pageNumber: number | string) => {
    const params = new URLSearchParams(searchParams);
    params.set("page", pageNumber.toString());
    return `${pathname}?${params.toString()}`;
  };

  // 📋 生成分页数组
  const allPages = generatePagination(currentPage, totalPages);

  return (
    <div className="inline-flex">
      {/* 前一页按钮 */}
      <PaginationArrow
        direction="left"
        href={createPageURL(currentPage - 1)}
        isDisabled={currentPage <= 1}
      />

      {/* 页码按钮 */}
      <div className="flex -space-x-px">
        {allPages.map((page, index) => {
          let position: 'first' | 'last' | 'single' | 'middle' | undefined;

          if (index === 0) position = 'first';
          if (index === allPages.length - 1) position = 'last';
          if (allPages.length === 1) position = 'single';
          if (page === '...') position = 'middle';

          return (
            <PaginationNumber
              key={`${page}-${index}`}
              href={createPageURL(page)}
              page={page}
              position={position}
              isActive={currentPage === page}
            />
          );
        })}
      </div>

      {/* 下一页按钮 */}
      <PaginationArrow
        direction="right"
        href={createPageURL(currentPage + 1)}
        isDisabled={currentPage >= totalPages}
      />
    </div>
  );
}
```

### 智能分页算法 (`app/lib/utils.ts`)

#### 分页数组生成逻辑
```typescript
export const generatePagination = (currentPage: number, totalPages: number) => {
  // 情况 1: 总页数 ≤ 7，显示所有页码
  if (totalPages <= 7) {
    return Array.from({ length: totalPages }, (_, i) => i + 1);
  }

  // 情况 2: 当前页在前 3 页
  if (currentPage <= 3) {
    return [1, 2, 3, '...', totalPages - 1, totalPages];
  }

  // 情况 3: 当前页在后 3 页
  if (currentPage >= totalPages - 2) {
    return [1, 2, '...', totalPages - 2, totalPages - 1, totalPages];
  }

  // 情况 4: 当前页在中间
  return [
    1,
    '...',
    currentPage - 1,
    currentPage,
    currentPage + 1,
    '...',
    totalPages,
  ];
};
```

#### 分页算法示例

**总页数 ≤ 7**
```
总页数: 5
显示: [1] [2] [3] [4] [5]
```

**当前页在前 3 页**
```
当前页: 2, 总页数: 10
显示: [1] [2] [3] [...] [9] [10]
```

**当前页在后 3 页**
```
当前页: 9, 总页数: 10
显示: [1] [2] [...] [8] [9] [10]
```

**当前页在中间**
```
当前页: 5, 总页数: 10
显示: [1] [...] [4] [5] [6] [...] [10]
```

## 数据获取层

### 表格组件 (`app/ui/invoices/table.tsx`)

#### 服务器端数据获取
```typescript
export default async function InvoicesTable({
  query,
  currentPage,
}: {
  query: string;
  currentPage: number;
}) {
  // 🗃️ 服务器端获取过滤后的发票数据
  const invoices = await fetchFilteredInvoices(query, currentPage);

  return (
    <div className="mt-6 flow-root">
      <div className="inline-block min-w-full align-middle">
        <div className="rounded-lg bg-gray-50 p-2 md:pt-0">

          {/* 📱 移动端卡片布局 */}
          <div className="md:hidden">
            {invoices?.map((invoice) => (
              <div key={invoice.id} className="mb-2 w-full rounded-md bg-white p-4">
                <div className="flex items-center justify-between border-b pb-4">
                  <div>
                    <div className="mb-2 flex items-center">
                      <Image
                        src={invoice.image_url}
                        className="mr-2 rounded-full"
                        width={28}
                        height={28}
                        alt={`${invoice.name}'s profile picture`}
                      />
                      <p>{invoice.name}</p>
                    </div>
                    <p className="text-sm text-gray-500">{invoice.email}</p>
                  </div>
                  <InvoiceStatus status={invoice.status} />
                </div>
                <div className="flex w-full items-center justify-between pt-4">
                  <div>
                    <p className="text-xl font-medium">
                      {formatCurrency(invoice.amount)}
                    </p>
                    <p>{formatDateToLocal(invoice.date)}</p>
                  </div>
                  <div className="flex justify-end gap-2">
                    <UpdateInvoice id={invoice.id} />
                    <DeleteInvoice id={invoice.id} />
                  </div>
                </div>
              </div>
            ))}
          </div>

          {/* 🖥️ 桌面端表格布局 */}
          <table className="hidden min-w-full text-gray-900 md:table">
            <thead className="rounded-lg text-left text-sm font-normal">
              <tr>
                <th scope="col" className="px-4 py-5 font-medium sm:pl-6">Customer</th>
                <th scope="col" className="px-3 py-5 font-medium">Email</th>
                <th scope="col" className="px-3 py-5 font-medium">Amount</th>
                <th scope="col" className="px-3 py-5 font-medium">Date</th>
                <th scope="col" className="px-3 py-5 font-medium">Status</th>
                <th scope="col" className="relative py-3 pl-6 pr-3">
                  <span className="sr-only">Edit</span>
                </th>
              </tr>
            </thead>
            <tbody className="bg-white">
              {invoices?.map((invoice) => (
                <tr key={invoice.id} className="w-full border-b py-3 text-sm last-of-type:border-none">
                  <td className="whitespace-nowrap py-3 pl-6 pr-3">
                    <div className="flex items-center gap-3">
                      <Image
                        src={invoice.image_url}
                        className="rounded-full"
                        width={28}
                        height={28}
                        alt={`${invoice.name}'s profile picture`}
                      />
                      <p>{invoice.name}</p>
                    </div>
                  </td>
                  <td className="whitespace-nowrap px-3 py-3">{invoice.email}</td>
                  <td className="whitespace-nowrap px-3 py-3">{formatCurrency(invoice.amount)}</td>
                  <td className="whitespace-nowrap px-3 py-3">{formatDateToLocal(invoice.date)}</td>
                  <td className="whitespace-nowrap px-3 py-3">
                    <InvoiceStatus status={invoice.status} />
                  </td>
                  <td className="whitespace-nowrap py-3 pl-6 pr-3">
                    <div className="flex justify-end gap-3">
                      <UpdateInvoice id={invoice.id} />
                      <DeleteInvoice id={invoice.id} />
                    </div>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  );
}
```

### 数据库查询函数 (`app/lib/data.ts`)

#### 过滤查询
```typescript
export async function fetchFilteredInvoices(
  query: string,
  currentPage: number,
) {
  const offset = (currentPage - 1) * ITEMS_PER_PAGE;

  try {
    const invoices = await sql<InvoicesTable[]>`
      SELECT
        invoices.id,
        invoices.amount,
        invoices.date,
        invoices.status,
        customers.name,
        customers.email,
        customers.image_url
      FROM invoices
      JOIN customers ON invoices.customer_id = customers.id
      WHERE
        customers.name ILIKE ${`%${query}%`} OR
        customers.email ILIKE ${`%${query}%`} OR
        invoices.amount::text ILIKE ${`%${query}%`} OR
        invoices.date::text ILIKE ${`%${query}%`} OR
        invoices.status ILIKE ${`%${query}%`}
      ORDER BY invoices.date DESC
      LIMIT ${ITEMS_PER_PAGE} OFFSET ${offset}
    `;

    return invoices;
  } catch (error) {
    console.error('Database Error:', error);
    throw new Error('Failed to fetch invoices.');
  }
}
```

#### 分页计算
```typescript
export async function fetchInvoicesPages(query: string) {
  try {
    const data = await sql`SELECT COUNT(*)
    FROM invoices
    JOIN customers ON invoices.customer_id = customers.id
    WHERE
      customers.name ILIKE ${`%${query}%`} OR
      customers.email ILIKE ${`%${query}%`} OR
      invoices.amount::text ILIKE ${`%${query}%`} OR
      invoices.date::text ILIKE ${`%${query}%`} OR
      invoices.status ILIKE ${`%${query}%`}
  `;

    const totalPages = Math.ceil(Number(data[0].count) / ITEMS_PER_PAGE);
    return totalPages;
  } catch (error) {
    console.error('Database Error:', error);
    throw new Error('Failed to fetch total number of invoices.');
  }
}
```

## 技术栈和依赖

### 核心依赖
```json
{
  "use-debounce": "^10.0.4",     // 防抖功能
  "next": "15.6.0-canary.20",    // Next.js 框架
  "react": "latest",              // React 框架
  "typescript": "5.7.3"          // TypeScript 支持
}
```

### Next.js 功能
- **App Router**：基于文件系统的路由
- **Server Components**：服务器端数据获取
- **Client Components**：客户端交互逻辑
- **Suspense**：流式传输和加载状态

### TypeScript 配置更新
```json
{
  "compilerOptions": {
    "jsx": "react-jsx",  // 更新为 React 17+ JSX transform
    "target": "ES2017",  // 支持现代 JavaScript 特性
    "strict": true       // 严格类型检查
  }
}
```

## 用户体验优化

### 响应式设计
```css
/* 移动端：卡片布局 */
.md:hidden {
  /* 堆叠卡片显示 */
}

/* 桌面端：表格布局 */
.hidden.md:table {
  /* 标准表格显示 */
}
```

### 加载状态
```typescript
// 骨架屏提供即时反馈
<Suspense fallback={<InvoicesTableSkeleton />}>
  <Table query={query} currentPage={currentPage} />
</Suspense>
```

### 防抖优化
```typescript
// 减少不必要的 API 请求
const handleSearch = useDebouncedCallback((term) => {
  // 搜索逻辑
}, 300);  // 300ms 延迟
```

## 性能优化策略

### 服务器端优化
1. **SQL 查询优化**：使用索引和 LIMIT/OFFSET
2. **数据分页**：固定每页 6 条记录
3. **JOIN 优化**：一次查询获取所有必要数据

### 客户端优化
1. **防抖搜索**：减少服务器请求
2. **URL 状态**：页面刷新保持状态
3. **Suspense 流式传输**：改善感知性能

### 缓存策略
```typescript
// 可以添加的缓存优化
const cachedResults = useMemo(() => {
  return expensiveCalculation(data);
}, [data]);
```

## 无障碍性支持

### 语义化 HTML
```html
<!-- 搜索表单 -->
<label htmlFor="search" className="sr-only">Search</label>
<input id="search" />

<!-- 表格标题 -->
<th scope="col">Customer</th>

<!-- 屏幕阅读器文本 -->
<span className="sr-only">Edit</span>
```

### 键盘导航
- 搜索框支持标准键盘操作
- 分页按钮支持 Tab 导航
- 表格支持键盘访问

## 扩展功能

### 高级搜索
```typescript
// 可以扩展的搜索功能
interface AdvancedSearchParams {
  query?: string;
  status?: 'paid' | 'pending';
  dateRange?: {
    start: Date;
    end: Date;
  };
  amountRange?: {
    min: number;
    max: number;
  };
}
```

### 排序功能
```typescript
// 可以添加的排序功能
interface SortParams {
  field: 'name' | 'email' | 'amount' | 'date' | 'status';
  direction: 'asc' | 'desc';
}
```

### 批量操作
```typescript
// 可以扩展的批量功能
interface BatchActions {
  selectedIds: string[];
  action: 'delete' | 'markPaid' | 'export';
}
```

## 测试策略

### 单元测试
```typescript
// 搜索功能测试
describe('Search Component', () => {
  test('should debounce search input', () => {
    // 测试防抖功能
  });

  test('should update URL with search query', () => {
    // 测试 URL 更新
  });
});
```

### 集成测试
```typescript
// 分页功能测试
describe('Pagination Component', () => {
  test('should generate correct page numbers', () => {
    // 测试分页算法
  });

  test('should navigate between pages', () => {
    // 测试页面导航
  });
});
```

## 总结

搜索与分页功能展示了现代 Web 应用的最佳实践：

### ✅ 核心特性
- **实时搜索**：300ms 防抖 + URL 状态同步
- **智能分页**：自适应省略号算法
- **响应式设计**：移动端卡片 + 桌面端表格
- **流式传输**：Suspense 支持的加载状态

### 🚀 性能优势
- **服务器端分页**：减少数据传输量
- **防抖搜索**：减少不必要的请求
- **URL 状态管理**：页面刷新保持状态
- **SQL 优化**：高效的数据库查询

### 💡 用户体验
- **即时反馈**：输入时实时搜索结果
- **状态持久化**：刷新页面保持搜索和分页状态
- **加载指示**：骨架屏提供视觉反馈
- **无障碍支持**：完整的键盘和屏幕阅读器支持

这个实现为用户提供了流畅、高效的数据浏览体验，同时保持了代码的可维护性和可扩展性。